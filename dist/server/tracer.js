"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QTracer = void 0;

var _noop = require("opentracing/lib/noop");

var _opentracing = require("opentracing");

var _jaegerClient = require("jaeger-client");

class QTracer {
  static create(config) {
    QTracer.config = config;
    const endpoint = config.jaeger.endpoint;

    if (!endpoint) {
      return _noop.tracer;
    }

    return (0, _jaegerClient.initTracerFromEnv)({
      serviceName: config.jaeger.service,
      sampler: {
        type: 'const',
        param: 1
      },
      reporter: {
        collectorEndpoint: endpoint,
        logSpans: true
      }
    }, {
      logger: {
        info(msg) {
          console.log('INFO ', msg);
        },

        error(msg) {
          console.log('ERROR', msg);
        }

      }
    });
  }

  static extractParentSpan(tracer, req) {
    let ctx_src, ctx_frm;

    if (req.headers) {
      ctx_src = req.headers;
      ctx_frm = _opentracing.FORMAT_TEXT_MAP;
    } else {
      ctx_src = req.context;
      ctx_frm = _opentracing.FORMAT_BINARY;
    }

    return tracer.extract(ctx_frm, ctx_src);
  }

  static getParentSpan(tracer, context) {
    return context.tracerParentSpan;
  }

  static failed(tracer, span, error) {
    span.log({
      event: 'failed',
      payload: error
    });
  }

  static async trace(tracer, name, f, parentSpan) {
    const span = tracer.startSpan(name, {
      childOf: parentSpan
    });

    try {
      span.setTag(_opentracing.Tags.SPAN_KIND, 'server');
      Object.entries(QTracer.config.jaeger.tags).forEach(([name, value]) => {
        if (name) {
          span.setTag(name, value);
        }
      });
      const result = await f(span);

      if (result !== undefined) {
        span.setTag('result', result);
      }

      span.finish();
      return result;
    } catch (error) {
      QTracer.failed(tracer, span, error);
      span.finish();
      throw error;
    }
  }

}

exports.QTracer = QTracer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NlcnZlci90cmFjZXIuanMiXSwibmFtZXMiOlsiUVRyYWNlciIsImNyZWF0ZSIsImNvbmZpZyIsImVuZHBvaW50IiwiamFlZ2VyIiwibm9vcFRyYWNlciIsInNlcnZpY2VOYW1lIiwic2VydmljZSIsInNhbXBsZXIiLCJ0eXBlIiwicGFyYW0iLCJyZXBvcnRlciIsImNvbGxlY3RvckVuZHBvaW50IiwibG9nU3BhbnMiLCJsb2dnZXIiLCJpbmZvIiwibXNnIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwiZXh0cmFjdFBhcmVudFNwYW4iLCJ0cmFjZXIiLCJyZXEiLCJjdHhfc3JjIiwiY3R4X2ZybSIsImhlYWRlcnMiLCJGT1JNQVRfVEVYVF9NQVAiLCJjb250ZXh0IiwiRk9STUFUX0JJTkFSWSIsImV4dHJhY3QiLCJnZXRQYXJlbnRTcGFuIiwidHJhY2VyUGFyZW50U3BhbiIsImZhaWxlZCIsInNwYW4iLCJldmVudCIsInBheWxvYWQiLCJ0cmFjZSIsIm5hbWUiLCJmIiwicGFyZW50U3BhbiIsInN0YXJ0U3BhbiIsImNoaWxkT2YiLCJzZXRUYWciLCJUYWdzIiwiU1BBTl9LSU5EIiwiT2JqZWN0IiwiZW50cmllcyIsInRhZ3MiLCJmb3JFYWNoIiwidmFsdWUiLCJyZXN1bHQiLCJ1bmRlZmluZWQiLCJmaW5pc2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFHQTs7QUFDQTs7QUFFQTs7QUFFTyxNQUFNQSxPQUFOLENBQWM7QUFFakIsU0FBT0MsTUFBUCxDQUFjQyxNQUFkLEVBQXVDO0FBQ25DRixJQUFBQSxPQUFPLENBQUNFLE1BQVIsR0FBaUJBLE1BQWpCO0FBQ0EsVUFBTUMsUUFBUSxHQUFHRCxNQUFNLENBQUNFLE1BQVAsQ0FBY0QsUUFBL0I7O0FBQ0EsUUFBSSxDQUFDQSxRQUFMLEVBQWU7QUFDWCxhQUFPRSxZQUFQO0FBQ0g7O0FBQ0QsV0FBTyxxQ0FBaUI7QUFDcEJDLE1BQUFBLFdBQVcsRUFBRUosTUFBTSxDQUFDRSxNQUFQLENBQWNHLE9B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InNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB0eXBlIHsgUUNvbmZpZyB9IGZyb20gXCIuL2NvbmZpZ1wiO1xuaW1wb3J0IHsgdHJhY2VyIGFzIG5vb3BUcmFjZXIgfSBmcm9tIFwib3BlbnRyYWNpbmcvbGliL25vb3BcIjtcbmltcG9ydCB7IFRyYWNlciwgVGFncywgRk9STUFUX1RFWFRfTUFQLCBGT1JNQVRfQklOQVJZLCBTcGFuLCBTcGFuQ29udGV4dCB9IGZyb20gXCJvcGVudHJhY2luZ1wiO1xuXG5pbXBvcnQgeyBpbml0VHJhY2VyRnJvbUVudiBhcyBpbml0SmFlZ2VyVHJhY2VyIH0gZnJvbSAnamFlZ2VyLWNsaWVudCc7XG5cbmV4cG9ydCBjbGFzcyBRVHJhY2VyIHtcbiAgICBzdGF0aWMgY29uZmlnOiBRQ29uZmlnO1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnOiBRQ29uZmlnKTogVHJhY2VyIHtcbiAgICAgICAgUVRyYWNlci5jb25maWcgPSBjb25maWc7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gY29uZmlnLmphZWdlci5lbmRwb2ludDtcbiAgICAgICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3BUcmFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluaXRKYWVnZXJUcmFjZXIoe1xuICAgICAgICAgICAgc2VydmljZU5hbWU6IGNvbmZpZy5qYWVnZXIuc2VydmljZSxcbiAgICAgICAgICAgIHNhbXBsZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29uc3QnLFxuICAgICAgICAgICAgICAgIHBhcmFtOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcG9ydGVyOiB7XG4gICAgICAgICAgICAgICAgY29sbGVjdG9yRW5kcG9pbnQ6IGVuZHBvaW50LFxuICAgICAgICAgICAgICAgIGxvZ1NwYW5zOiB0cnVlLFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsb2dnZXI6IHtcbiAgICAgICAgICAgICAgICBpbmZvKG1zZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSU5GTyAnLCBtc2cpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3IobXNnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFUlJPUicsIG1zZyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBleHRyYWN0UGFyZW50U3Bhbih0cmFjZXI6IFRyYWNlciwgcmVxOiBhbnkpOiBhbnkge1xuICAgICAgICBsZXQgY3R4X3NyYywgY3R4X2ZybTtcbiAgICAgICAgaWYgKHJlcS5oZWFkZXJzKSB7XG4gICAgICAgICAgICBjdHhfc3JjID0gcmVxLmhlYWRlcnM7XG4gICAgICAgICAgICBjdHhfZnJtID0gRk9STUFUX1RFWFRfTUFQO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4X3NyYyA9IHJlcS5jb250ZXh0O1xuICAgICAgICAgICAgY3R4X2ZybSA9IEZPUk1BVF9CSU5BUlk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNlci5leHRyYWN0KGN0eF9mcm0sIGN0eF9zcmMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRQYXJlbnRTcGFuKHRyYWNlcjogVHJhY2VyLCBjb250ZXh0OiBhbnkpOiAoU3BhbkNvbnRleHQgfCB0eXBlb2YgdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnRyYWNlclBhcmVudFNwYW47XG4gICAgfVxuXG4gICAgc3RhdGljIGZhaWxlZCh0cmFjZXI6IFRyYWNlciwgc3BhbjogU3BhbiwgZXJyb3I6IGFueSkge1xuICAgICAgICBzcGFuLmxvZyh7IGV2ZW50OiAnZmFpbGVkJywgcGF5bG9hZDogZXJyb3IgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIHRyYWNlPFQ+KFxuICAgICAgICB0cmFjZXI6IFRyYWNlcixcbiAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICBmOiAoc3BhbjogU3BhbikgPT4gUHJvbWlzZTxUPixcbiAgICAgICAgcGFyZW50U3Bhbj86IChTcGFuIHwgU3BhbkNvbnRleHQpXG4gICAgKTogUHJvbWlzZTxUPiB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0cmFjZXIuc3RhcnRTcGFuKG5hbWUsIHsgY2hpbGRPZjogcGFyZW50U3BhbiB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNwYW4uc2V0VGFnKFRhZ3MuU1BBTl9LSU5ELCAnc2VydmVyJyk7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhRVHJhY2VyLmNvbmZpZy5qYWVnZXIudGFncykuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0VGFnKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGYoc3Bhbik7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldFRhZygncmVzdWx0JywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwYW4uZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgUVRyYWNlci5mYWlsZWQodHJhY2VyLCBzcGFuLCBlcnJvcik7XG4gICAgICAgICAgICBzcGFuLmZpbmlzaCgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=